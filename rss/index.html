<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Xander's Lander]]></title><description><![CDATA[Welcome to my little playground]]></description><link>https://xander-rudolph.github.io/</link><image><url>https://xander-rudolph.github.io/favicon.png</url><title>Xander&apos;s Lander</title><link>https://xander-rudolph.github.io/</link></image><generator>Ghost 5.45</generator><lastBuildDate>Sat, 29 Apr 2023 13:32:02 GMT</lastBuildDate><atom:link href="https://xander-rudolph.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[PowerShell Packages - Caution]]></title><description><![CDATA[<!--kg-card-begin: html--><b style="color:red;">NOTE: This post gets a little into the weeds on powershell and can break things if not done correctly. When working with PowerShellGet and PackageManagement, things can get a little weird because they have been around for ages and have pretty Frankenstein fixes to support legacy.</b><!--kg-card-end: html--><h2 id="powershellget-and-packagemanagement">PowerShellGet and PackageManagement</h2><p>First</p>]]></description><link>https://xander-rudolph.github.io/powershell-packages/</link><guid isPermaLink="false">644d180f5752400001d6e7a6</guid><dc:creator><![CDATA[Alex Rudolph]]></dc:creator><pubDate>Sat, 29 Apr 2023 13:21:06 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: html--><b style="color:red;">NOTE: This post gets a little into the weeds on powershell and can break things if not done correctly. When working with PowerShellGet and PackageManagement, things can get a little weird because they have been around for ages and have pretty Frankenstein fixes to support legacy.</b><!--kg-card-end: html--><h2 id="powershellget-and-packagemanagement">PowerShellGet and PackageManagement</h2><p>First we are going to cover the two fundamental modules that run most module/package stuff in PowerShell. PackageManagement and PowerShellGet work hand in hand with each other. When you run Install-module for PackageManagement you will generally get a failure because you are currently using PackageManagement because PowerShellGet is using it to run Install-Module (meta... I know). There are dozens of tutorials that explain this in more detail so I won&apos;t get in to the specifics, just recommend the following command:</p><!--kg-card-begin: markdown--><pre><code class="language-shell">powershell.exe -NoLogo -NoProfile -Command &apos;[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; Install-Module -Name PackageManagement -Force -MinimumVersion 1.4.6 -Scope AllUsers -AllowClobber -Repository PSGallery&apos;
</code></pre>
<!--kg-card-end: markdown--><p>This will run the install command in a new session and should upgrade your PackageManagement.</p><h2 id="what-just-happened">What just happened?</h2><p>The script above is actually doing something quite simple. Windows will store packages in the <code>%programfiles%\WindowsPowerShell</code> directory. This is the <strong>GLOBAL</strong> location for modules. When you run powershell as an admin, this is where modules go. When you are not running as an admin, it will generally use <code>%userprofile%\Documents\WindowsPowerShell</code>. These settings can be tweaked/overridden using <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1&amp;ref=localhost" rel="noreferrer noopener">profile scripts</a>. If you navigate to the WindowsPowerShell directory you will find a modules folder, which will have a PackageManagment folder. In that folder you will see the different versions that you have installed. Additionally you can use the following command to see what powershell is loading from <code>$ENV:PSMODULEPATH</code>:<br><code>Get-InstalledModule</code></p><h2 id="module-and-script-construction">Module and script construction</h2><p>I have put together a simple module that uses some simple PowerShell functions to build templates for scripts and modules. Run the following commands:<br><code>install-module xanderu.helpers </code><br><code>New-PowershellTemplate</code></p><p>This will automatically create a module or script based on the input prompts. If you haven&apos;t specified a directory, it will use the current directory to create the structure.</p><h2 id="loading-and-debugging-modules">Loading and debugging modules</h2><p>Without a pipeline, loading and debugging modules is actually quite simple. By copying the module into the <code>%programfiles%\WindowsPowerShell</code> directory it will auto load when you open powershell. This can cause issues when debugging as it can get confusing when you are trying to make changes. You will not be sure what version of the modules functions you are using. Instead, when debugging use:<br><code>Import-Module -force -allowclobber .\Path\to\module.psm1</code></p><p>This will allow you to specify exactly what module you want to load. It will automatically override and replace any functions you have in your current session.</p>]]></content:encoded></item><item><title><![CDATA[Just some helpful PowerShell]]></title><description><![CDATA[<!--kg-card-begin: html--><h2>Where to start with powershell</h2><!--kg-card-end: html--><p>I&apos;ve build a helper function that anyone can use to get a simple pipeline off the ground and have it prepped and ready for use in Azure Devops. The module can also be found in the <a href="https://www.powershellgallery.com/packages/xanderu.helpers?ref=localhost" rel="noreferrer noopener">PSGallery</a>.</p><p>I have not done very robust</p>]]></description><link>https://xander-rudolph.github.io/just-some-helpful-powershell/</link><guid isPermaLink="false">644d12a35752400001d6e706</guid><dc:creator><![CDATA[Alex Rudolph]]></dc:creator><pubDate>Sat, 29 Apr 2023 13:12:58 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: html--><h2>Where to start with powershell</h2><!--kg-card-end: html--><p>I&apos;ve build a helper function that anyone can use to get a simple pipeline off the ground and have it prepped and ready for use in Azure Devops. The module can also be found in the <a href="https://www.powershellgallery.com/packages/xanderu.helpers?ref=localhost" rel="noreferrer noopener">PSGallery</a>.</p><p>I have not done very robust documentation on this pipeline because its all pretty generic. When working with powershell there are many standards that can, but do not need to be, applied to script or module files but they aren&apos;t required. The module above is simply a template that will stamp out the file/folder stucture that is needed for publishing a module with each function broken down for easy of use and portability.</p><!--kg-card-begin: html--><h2>Where you run matters</h2><!--kg-card-end: html--><p>When using powershell, the context in which you start powershell changes how it operates. This can be seen most obviously with a simple powershell builtin called $PSVersionTable:</p><figure class="kg-card kg-image-card"><img src="https://xander-rudolph.github.io/content/images/2023/04/image2021-2-19_6-46-10.png" class="kg-image" alt loading="lazy" width="395" height="177"></figure><p>PSVersiontable will print out the version of powershell you are running. If you have multiple versions of powershell installed, you may need to switch the context. With VS Code, you can use CTRL+SHIFT+P and then type &quot;Session&quot; to change the version of powershell in the terminal:</p><figure class="kg-card kg-image-card"><img src="https://xander-rudolph.github.io/content/images/2023/04/image2021-2-19_6-49-54.png" class="kg-image" alt loading="lazy" width="623" height="82" srcset="https://xander-rudolph.github.io/content/images/size/w600/2023/04/image2021-2-19_6-49-54.png 600w, https://xander-rudolph.github.io/content/images/2023/04/image2021-2-19_6-49-54.png 623w"></figure><p>If you look at the VS Code <code>settings.json</code> (the default path is <code>%appdata%\Code\User\settings.json</code>) you can see what default PowerShell is being used: <br>&quot;powershell.powerShellDefaultVersion&quot;: &quot;Windows PowerShell (x64)&quot; </p><p>It&apos;s important to know what context you are running in because some things may or may not work because of localized settings. Managing how and where you run your code has a big impact on how errors will present themselves and what will be supported.</p><!--kg-card-begin: html--><h2>Installing core</h2><!--kg-card-end: html--><p>The screenshot above is what generally will show up on your windows machine if you use PowerShell on a windows host. PowerShell started to diverge in v6 (AKA PowerShell core) and doesn&apos;t natively come on any OS. </p><p>For Windows:<br><code>winget install --id Microsoft.Powershell --source winget</code><br>For Mac:<br><code>brew install powershell</code><br>For Linux:<br><code>snap install powershell --classic</code></p><h2 id="what-gives-with-the-versions"><strong>What gives with the versions?</strong></h2><p>PowerShell has been around for a long time in the windows space, however PowerShell 6 and up are cross platform. There are limiting factors to writing cross platform scripts, namely related to .net libraries. A script that is designed for PowerShell 5.1 (windows) is likely only going to work on windows because of the various .net frameworks that come prepackaged on windows installations. For example, if a PowerShell script is using pop up forms (windows forms in .net) it won&apos;t work on a Linux or Mac because the Windows forms libraries are not available. Some libraries have also become cross platform and can be found in .net core (versions can change what options you will have available).</p><h2 id="what-does-that-look-like">What does that look like?</h2><p>When using cross platform modules, you can make things look and act differently depending on the OS or context in which it&apos;s called. For example, the <code>Get-Credential</code> function when called from a windows PowerShell terminal will give a pop up:</p><figure class="kg-card kg-image-card"><img src="https://xander-rudolph.github.io/content/images/2023/04/image2021-2-19_7-12-54.png" class="kg-image" alt loading="lazy" width="321" height="259"></figure><p>And when you use a PowerShell session in PS core on the same machine you will get a command line prompt:</p><figure class="kg-card kg-image-card"><img src="https://xander-rudolph.github.io/content/images/2023/04/image2021-2-19_7-12-40.png" class="kg-image" alt loading="lazy" width="380" height="100"></figure><h2 id="in-summary">In Summary</h2><p>When working with PowerShell it&apos;s important to understand how and where you are planning to run your scripts. The way PowerShell operates is going to be different based on the version, the context, and the features you have installed on your local machine. Where possible, it is best to include any required DLLs/EXE files you might need and use relative pathing to make your scripts more portable/packable. This can sometimes bloat the size of your code base, but if you don&apos;t include it, a check in the script/module to make sure all dependencies are met is a good idea. This can be done with <code>#requires</code> or <code>.MODULESREQUIRED</code> or by writing up explicit checks in the source to throw tailored errors.</p>]]></content:encoded></item><item><title><![CDATA[Running MediaKube-redux]]></title><description><![CDATA[<p>I will elaborate more on this when I fix the VPN for saftey.</p>]]></description><link>https://xander-rudolph.github.io/running-mediakube-redux/</link><guid isPermaLink="false">644c38d62f0a6f0001cd6aad</guid><dc:creator><![CDATA[Alex Rudolph]]></dc:creator><pubDate>Fri, 28 Apr 2023 21:21:52 GMT</pubDate><content:encoded><![CDATA[<p>I will elaborate more on this when I fix the VPN for saftey.</p>]]></content:encoded></item><item><title><![CDATA[Build your own]]></title><description><![CDATA[<p>If you want to build your own site like this, all you need is the pipeline and the following docker command:</p><pre><code class="language-shell">docker run --name ghost --rm -p 2368:2368 -e NODE_ENV=development -e database__connection__filename=&apos;/var/lib/ghost/content/data/ghost.db&apos; -v $PWD/content:/var/</code></pre>]]></description><link>https://xander-rudolph.github.io/welcome-to-my-little-playground/</link><guid isPermaLink="false">644aecdfc96e22000148dcbc</guid><dc:creator><![CDATA[Alex Rudolph]]></dc:creator><pubDate>Thu, 27 Apr 2023 21:45:42 GMT</pubDate><media:content url="https://xander-rudolph.github.io/content/images/2023/04/00001-4087422604-3.png" medium="image"/><content:encoded><![CDATA[<img src="https://xander-rudolph.github.io/content/images/2023/04/00001-4087422604-3.png" alt="Build your own"><p>If you want to build your own site like this, all you need is the pipeline and the following docker command:</p><pre><code class="language-shell">docker run --name ghost --rm -p 2368:2368 -e NODE_ENV=development -e database__connection__filename=&apos;/var/lib/ghost/content/data/ghost.db&apos; -v $PWD/content:/var/lib/ghost/content ghost:alpine </code></pre><p>This will start a local instance of ghost to generate the database itself. Once the code is commited to your repo, it will automatically build your GitHub sit based on your username. <a href="https://pages.github.com/?ref=localhost">Github pages</a> reserve {username}.github.io repo names and build sites automatically for you. My public .github repo has an automated build repo and the push to your github.io repo. The following code will invoke the public pipeline using your username:</p><pre><code>name: Build Repo and Ghost

on:
  workflow_dispatch:
    branches:
      - main
  push:
    branches:
      - main

jobs:
  deploy:
    # uses: ./.github/workflows/build-and-deploy.yaml
    uses: xander-rudolph/.github/.github/workflows/build-and-deploy.yaml@master
    with:
      github-user: ${{ github.actor }}
    secrets: inherit</code></pre><p>When code is pushed to main, the docker image will build out the static content and publish the site.</p>]]></content:encoded></item></channel></rss>